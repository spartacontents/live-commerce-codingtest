import java.io.IOException;
import java.util.ArrayDeque;

public class 스파르타_코테_05 {
    /*
    [제목]
    얼음 미로

    [문제 설명]
    르탄이는 테마파크 겨울왕국에 놀러갔다. 겨울왕국에는 "얼음 미로"라는 공간이 있는데, "얼음 미로"는 크기가 n x m 인 직사각형으로 나타낼 수 있으며, 직사각형은 1 x 1 크기의 정사각형으로 나누어져 있고, 이를 하나의 칸 이라고 칭한다.
    "얼음 미로"의 칸은 [빈 칸], [얼음 벽] 으로 구성되어 있으며, [얼음 벽] 으로 구성된 칸은 시간이 지날수록 서서히 녹아, 일정 시간이 흐르면 [빈 칸] 으로 변한다.
     예를 들어 아래와 같이 "얼음 미로"가 있는 경우를 생각해보자

        ```
        0   2   1    1   1
        0  10   8  100   1
        1  10   7  100   1
        2  10   6  100  10
        3   4   5  100   0
        ```

    이 때, 0은 [빈 칸], 그 외 0보다 큰 수가 있는 칸은 [얼음 벽] 이며, [얼음 벽] 의 숫자는 [얼음 벽] 이 유지되는 시간을 의미한다. 즉 1행 2열에 있는 숫자 2 는 2분 후에는 전부 녹아서 사라지며, 그 즉시 [빈 칸] 으로 변한다.
    따라서, 8분 후에는 다음과 같이 변한다고 볼 수 있다.

        ```
        0   0   0    0   0
        0   2   0   92   0
        0   2   0   92   0
        0   2   0   92   2
        0   0   0   92   0
        ```

    르탄이는 가장 왼쪽 위 칸 (0, 0) 에서 출발하여, 가장 오른쪽 아래 칸 (n - 1, m - 1) 으로 탈출해야 한다.
    르탄이는 상, 하, 좌, 우 로 인접한 방향으로만 1분에 1칸씩 움직일 수 있으며, [빈 칸] 으로만 이동 가능하고, [얼음 벽] 이 녹아서 [빈 칸] 으로 변한 곳으로도 이동 가능하다. 즉 해당 칸에 [얼음 벽] 이 있으면 이동할 수 없다.
    르탄이가 "얼음 미로"를 탈출할 수 있는 최소 시간을 "분" 단위로 구해보자.
    위와 같은 예시에는 2분 후 아래와 같이 변하기 때문에 르탄이는 (0, 0) 에서 2분을 기다리고, 3분 후 1행 2열 (0, 1) 에 도착할 수 있다.

        ```
        0   H   0    0   0
        0   7   5   97   0
        0   7   4   97   0
        0   7   3   97   7
        0   1   2   97   0
        ```

    그리고 11분 후에는 4행 5열 (3, 4) 에 도착할 수 있으며, 12분 후에 미로를 탈출할 수 있다.

        ```
        0   0   0    0   0
        0   0   0   88   0
        0   0   0   88   0
        0   0   0   88   0
        0   0   0   88   H
        ```

    [제약 조건]
    미로의 크기 가로(n), 세로(m)는 3 <= n, m <= 1000 를 만족하는 자연수입니다.
    얼음 미로의 상태는 map으로 주어지며, 각 값은 0 은 [빈 칸], 0 이상의 자연수는 [얼음 벽] 이 있는 위치입니다.
    각 칸의 숫자 X는 0 <= X <= 1000 를 만족하는 정수입니다.

    [입출력 예시]
    예시 #1
    n = 5, m = 5, map = [0, 2, 1, 1, 1], [0, 10, 8, 100, 1], [1, 10, 7, 100, 1], [2, 10, 6, 100, 10], [3, 4, 5, 100, 0]

    [입출력 예시 설명]
    예시 #1
    문제 설명과 같으며 답은 12가 됩니다.
     */

    public static void main(String[] args) throws IOException {
        System.out.println(solution(5, 5, new int[][]{{0, 2, 1, 1, 1}, {0, 10, 8, 100, 1}, {1, 10, 7, 100, 1}, {2, 10, 6, 100, 10}, {3, 4, 5, 100, 0}}));
    }

    /*
    문제 해설 및 정답 코드
    기본적인 BFS 최단거리 탐색 문제입니다.
    상하좌우 4방향 최단거리 탐색을 수행합니다.
    얼음벽에 도착한 경우 얼음벽의 숫자가 최단거리의 숫자보다 크다면 최단거리를 1증가시키고 그 자리를 그대로 다시 큐에 넣으면 됩니다.
    얼음벽의 숫자가 최단거리의 숫자보다 작다면 얼음벽은 녹아서 사라진 것으로 볼 수 있으므로 기본적인 BFS 탐색을 이어가면 됩니다.
    이 문제는 다익스트라 알고리즘으로도 해결 가능합니다.
     */
    public static int solution(int n, int m, int[][] map) {
        dist = new int[n][m];

        ArrayDeque<Node> queue = new ArrayDeque<>();

        queue.addLast(new Node(0, 0));
        dist[0][0] = 0;
        map[0][0] = -1;

        while (!queue.isEmpty()) {
            Node now = queue.pollFirst();

            if (map[now.r][now.c] >= dist[now.r][now.c]) {
                dist[now.r][now.c]++;
                queue.addLast(now);
                continue;
            }

            for (int i = 0; i < 4; i++) {
                int nr = now.r + ry[i];
                int nc = now.c + rx[i];

                if (nr < 0 || nc < 0 || nr >= n || nc >= m)
                    continue;

                if (dist[nr][nc] > 0)
                    continue;

                dist[nr][nc] = dist[now.r][now.c] + 1;
                queue.addLast(new Node(nr, nc));
            }
        }

        return dist[n - 1][m - 1];
    }

    private static class Node {
        int r, c;

        public Node(int r, int c) {
            this.r = r;
            this.c = c;
        }
    }

    private static final int[] ry = {-1, 0, 1, 0};
    private static final int[] rx = {0, 1, 0, -1};

    private static int[][] dist;

}