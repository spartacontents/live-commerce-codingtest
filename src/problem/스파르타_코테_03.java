import java.util.Comparator;
import java.util.PriorityQueue;

class 스파르타_코테_03 {
    /*
    [제목]
    신용카드 소비 패턴

    [문제 설명]
    르탄이는 평소 쇼핑을 할 때 자신이 가진 신용카드 중에서 어떤 카드를 사용할지 선택하는 독특한 규칙을 갖고 있습니다.
    르탄이가 가진 모든 신용카드는 결제할 수 있는 금액에 일정 수준의 한도가 있으며, 남은 한도가 가장 높은 금액인 카드를 우선 사용합니다.
    그리고 특유의 고집 때문에 물건은 무조건 주어진 순서대로만 구입하며 한 번의 결제에 카드 2개 이상 사용하는 분할 결제는 하지 않습니다.
    예를 들어 르탄이가 카드 3개를 갖고 있고, 각 한도가 [500, 1000, 700]이고 구입하려는 물건의 가격이 [100, 500, 300, 400, 200, 500, 100]라면
    현재 남은 한도가 가장 높은 1000원인 카드로 처음 100원 짜리 물건을 구입하고 해당 카드의 남은 한도는 900이 됩니다.
    이후 500원 짜리 물건은 남은 한도가 가장 높은 900원인 카드로 구매하여 해당 카드의 남은 한도는 400이 됩니다.
    300원 짜리 물건은 남은 한도가 가장 높은 700원인 카드로 구매하여 해당 카드의 남은 한도는 400원이 됩니다.
    400원 짜리 물건은 남은 한도가 가장 높은 500원인 카드로 구매하여 해당 카드의 남은 한도는 100원이 됩니다.
    200원 짜리 물건은 남은 한도가 가장 높은 400원인 카드로 구매하여 해당 카드의 남은 한도는 200원이 됩니다.
    끝으로 500원 짜리 물건은 남은 한도가 가장 높은 카드가 400원이므로 구매가 불가능합니다.
    따라서 르탄이는 총 5개의 물건을 구매 가능합니다.
    르탄이가 가진 카드들의 현재 한도(cards)와 구입하려는 물건의 가격(price)이 구입 순서대로 주어질 때 르탄이가 구입 가능한 최대 물건의 개수를 반환하는 Solution 함수를 작성해주세요.

    [제약조건]
    르탄이가 가진 카드의 개수는 1 ~ 100,000 까지의 자연수입니다.
    각 카드의 최초 한도는 1 ~ 1,000,000 까지의 자연수입니다.
    르탄이가 구입하려는 물건의 개수는 1 ~ 100,000 까지의 자연수입니다.
    각 물건의 금액은 1 ~ 100,000 까지의 자연수입니다.

    [입출력 예시]
    예시 #1 cards = [500, 1000, 700], price = [100, 500, 300, 400, 200, 500, 100]
    예시 #2 cards = [100, 200, 300, 400], price = [500]
    예시 #3 cards = [10000], price = [800, 700, 600, 500, 400, 300, 200, 100]

    [입출력 예시 설명]
    예시 #1
    문제의 케이스와 동일하며 답은 5 입니다.

    예시 #2
    하나의 물건도 구매할 수 없으므로 답은 0 입니다.

    예시 #3
    모든 물건을 구매할수 있으므로 답은 8 입니다.
     */

    public static void main(String[] args) {
        //예시1
        System.out.println(solution(new int[]{500, 1000, 700}, new int[]{100, 500, 300, 400, 200, 500, 100}));

        //예시2
        System.out.println(solution(new int[]{100, 200, 300, 400}, new int[]{500}));

        //예시3
        System.out.println(solution(new int[]{10000}, new int[]{800, 700, 600, 500, 400, 300, 200, 100}));
    }

    public static int solution(int[] cards, int[] price) {
        int answer = 0;

        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());
        for (int card : cards) {
            pq.add(card);
        }

        for (int p : price) {
            if (pq.peek() >= p) {
                pq.add(pq.poll() - p);
                answer++;
            } else {
                break;
            }
        }

        return answer;
    }
}