import java.util.Comparator;
import java.util.PriorityQueue;

class Solution {
    /*
    [제목]
    신용카드 소비 패턴

    [문제 설명]
    르탄이는 평소 쇼핑을 할 때 자신이 가진 신용카드 중에서 어떤 카드를 사용할지 선택하는 독특한 규칙을 갖고 있습니다.
    르탄이가 가진 모든 신용카드는 결제할 수 있는 금액에 일정 수준의 한도가 있으며, 남은 한도가 가장 높은 금액인 카드를 우선 사용합니다.
    그리고 특유의 고집 때문에 물건은 무조건 주어진 순서대로만 구입하며 한 번의 결제에 카드 2개 이상 사용하는 분할 결제는 하지 않습니다.
    예를 들어 르탄이가 카드 3개를 갖고 있고, 각 한도가 [500, 1000, 700]이고 구입하려는 물건의 가격이 [100, 500, 300, 400, 200, 500, 100]라면
    현재 남은 한도가 가장 높은 1000원인 카드로 처음 100원 짜리 물건을 구입하고 해당 카드의 남은 한도는 900이 됩니다.
    이후 500원 짜리 물건은 남은 한도가 가장 높은 900원인 카드로 구매하여 해당 카드의 남은 한도는 400이 됩니다.
    300원 짜리 물건은 남은 한도가 가장 높은 700원인 카드로 구매하여 해당 카드의 남은 한도는 400원이 됩니다.
    400원 짜리 물건은 남은 한도가 가장 높은 500원인 카드로 구매하여 해당 카드의 남은 한도는 100원이 됩니다.
    200원 짜리 물건은 남은 한도가 가장 높은 400원인 카드로 구매하여 해당 카드의 남은 한도는 200원이 됩니다.
    끝으로 500원 짜리 물건은 남은 한도가 가장 높은 카드가 400원이므로 구매가 불가능합니다.
    따라서 르탄이는 총 5개의 물건을 구매 가능합니다.
    르탄이가 가진 카드들의 현재 한도(cards)와 구입하려는 물건의 가격(price)이 구입 순서대로 주어질 때 르탄이가 구입 가능한 최대 물건의 개수를 반환하는 Solution 함수를 작성해주세요.

    [제약조건]
    르탄이가 가진 카드의 개수 n은 1 ~ 100,000 까지의 자연수입니다.
    각 카드의 최초 한도는 1 ~ 1,000,000 까지의 자연수입니다.
    르탄이가 구입하려는 물건의 개수 m은 1 ~ 100,000 까지의 자연수입니다.
    각 물건의 금액은 1 ~ 100,000 까지의 자연수입니다.

    [입력 예시]
    예시 #1
    n = 3, m = 7, cards = [500, 1000, 700], price = [100, 500, 300, 400, 200, 500, 100]

    예시 #2
    n = 4, m = 1, cards = [100, 200, 300, 400], price = [500]

    예시 #3
    n = 1, m = 8, cards = [10000], price = [800, 700, 600, 500, 400, 300, 200, 100]

    [출력 예시 및 설명]
    예시 #1
    5

    문제의 케이스와 동일하며 답은 5 입니다.

    예시 #2
    0

    하나의 물건도 구매할 수 없으므로 답은 0 입니다.

    예시 #3
    8

    모든 물건을 구매할수 있으므로 답은 8 입니다.
     */

    public static void main(String[] args) {
        //예시1
        System.out.println(solution(3, 7, new int[]{500, 1000, 700}, new int[]{100, 500, 300, 400, 200, 500, 100}));

        //예시2
        System.out.println(solution(4, 1, new int[]{100, 200, 300, 400}, new int[]{500}));

        //예시3
        System.out.println(solution(1, 8, new int[]{10000}, new int[]{800, 700, 600, 500, 400, 300, 200, 100}));
    }

    /*
    문제 해설 및 정답 코드
    매 물건 구입시마다 한도가 가장 많이 남은 카드를 찾아야 하는데, 이 때 모든 카드의 남은 한도를 O(N)으로 찾게되면 시간 초과가 발생합니다.
    따라서 남은 한도 값이 가장 높은 카드를 빠르게 알아내는 방법이 필요합니다.
    우선순위 큐를 사용하면 매번 정렬하거나 O(N)으로 찾을 필요 없이 남은 한도가 가장 높은 카드를 빠르게 알아낼 수 있습니다.
    카드의 개수와 물건의 개수가 각 최대 100,000개 이므로 우선순위 큐를 사용하면 총 O(NlogN)의 시간복잡도로 이 문제를 해결할 수 있습니다.
    내림 차순으로 정렬되는 우선순위 큐를 하나 만듭니다.
    최초 모든 카드의 남은 한도를 우선순위 큐에 넣습니다.
    우선순위 큐에서 가장 높은 값을 하나 꺼내서 물건을 구매하고 물건 값 만큼 한도를 줄인 후에 다시 우선순위 큐에 넣습니다.
    이 과정을 큐에서 꺼낸 한도 금액이 물건 값보다 크거나 같은 경우까지만 반복하면 정답을 구할 수 있습니다.
     */
    public static int solution(int n, int m, int[] cards, int[] price) {
        int answer = 0;

        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());
        for (int card : cards) {
            pq.add(card);
        }

        for (int p : price) {
            if (pq.peek() >= p) {
                pq.add(pq.poll() - p);
                answer++;
            } else {
                break;
            }
        }

        return answer;
    }
}